:root {
    --bg-color: #0d1117;
    --grid-bg: #161b22;
    --cell-bg: #21262d;
    --accent-neon: #00f2ff;
    --text-main: #e6edf3;
}

body {
    background-color: var(--bg-color);
    color: var(--text-main);
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    overflow: hidden;
    touch-action: none;
}

.game-wrapper { width: 100%; max-width: 400px; padding: 10px; }

.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
.title { font-size: 24px; letter-spacing: 2px; font-weight: bold; margin: 0; }
.title span { color: var(--accent-neon); }

.score-container { display: flex; gap: 10px; }
.score-box { background: #30363d; padding: 8px 15px; border-radius: 6px; text-align: center; border: 1px solid #444c56; min-width: 65px; }
.label { display: block; font-size: 10px; text-transform: uppercase; color: #8b949e; }
.value { font-size: 18px; font-weight: bold; }

.btn { background: transparent; color: var(--accent-neon); border: 1px solid var(--accent-neon); padding: 10px 20px; border-radius: 6px; cursor: pointer; text-transform: uppercase; font-weight: bold; transition: 0.2s; }
.btn:hover { background: rgba(0, 242, 255, 0.1); box-shadow: 0 0 15px rgba(0, 242, 255, 0.4); }

.grid-container {
    position: relative;
    width: 380px; height: 380px;
    background-color: var(--grid-bg);
    border-radius: 8px;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    grid-gap: 12px;
    padding: 12px;
    box-sizing: border-box;
    border: 2px solid #30363d;
}

.grid-cell { background-color: var(--cell-bg); border-radius: 6px; }

.tile {
    position: absolute;
    border-radius: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 800;
    z-index: 10;
    transition: top 0.15s ease-in-out, left 0.15s ease-in-out;
    box-sizing: border-box;
}

/* ДИНАМИЧЕСКИЙ НЕОНОВЫЙ КЛАСС */
.tile-super { z-index: 12; }

.tile-super::after {
    content: '';
    position: absolute;
    /* Эти переменные прилетают из JS */
    top: var(--glow-size); 
    left: var(--glow-size); 
    right: var(--glow-size); 
    bottom: var(--glow-size);
    background: currentColor;
    border-radius: 50%;
    filter: blur(var(--glow-blur)); 
    opacity: var(--glow-opacity);
    z-index: -1;
    animation: neon-pulse 2s infinite alternate ease-in-out;
}

.tile-inner { font-size: 12px; text-align: center; width: 100%; pointer-events: none; text-transform: uppercase; position: relative; z-index: 2; }

@keyframes neon-pulse {
    from { opacity: calc(var(--glow-opacity) * 0.6); transform: scale(0.92); }
    to { opacity: var(--glow-opacity); transform: scale(1.08); }
}

@keyframes pop { 0% { transform: scale(0); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
@keyframes merge-pop { 0% { transform: scale(1); } 50% { transform: scale(1.15); } 100% { transform: scale(1); } }

.tile-new { animation: pop 0.2s ease-out; }
.tile-merged { animation: merge-pop 0.15s ease-in-out; }

.game-message {
    display: none;
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(13, 17, 23, 0.95);
    z-index: 100;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: var(--accent-neon);
}

.game-message p { 
    font-size: 42px; 
    font-weight: bold; 
    text-shadow: 0 0 10px var(--accent-neon), 0 0 30px var(--accent-neon); 
    margin-bottom: 20px;
    letter-spacing: 4px;
}

@media (max-width: 420px) { .grid-container { width: 300px; height: 300px; grid-gap: 8px; padding: 8px; } }



const ELEMENTS = [
    { name: "QUARK", color: "#00d4ff", textColor: "#000" },      // 0
    { name: "PROTON", color: "#0091ff", textColor: "#fff" },     // 1
    { name: "ATOM", color: "#4d3dff", textColor: "#fff" },       // 2
    { name: "CELL", color: "#8000ff", textColor: "#fff" },       // 3 -> Начало свечения
    { name: "SPARK", color: "#d400ff", textColor: "#fff" },      // 4
    { name: "PULSE", color: "#ff00d4", textColor: "#fff" },      // 5
    { name: "PLASMA", color: "#ff0066", textColor: "#fff" },     // 6
    { name: "LASER", color: "#ff4d00", textColor: "#fff" },      // 7
    { name: "STAR", color: "#ff9900", textColor: "#000" },       // 8
    { name: "NOVA", color: "#ffcc00", textColor: "#000" },       // 9
    { name: "PULSAR", color: "#ccff00", textColor: "#000" },     // 10
    { name: "QUASAR", color: "#00ffcc", textColor: "#000" },     // 11
    { name: "SINGULARITY", color: "#ffffff", textColor: "#000" } // 12
];

class Game2048 {
    constructor() {
        this.boardElement = document.getElementById('game-board');
        this.scoreElement = document.getElementById('current-score');
        this.bestScoreElement = document.getElementById('best-score');
        this.gameOverElement = document.getElementById('game-over');
        this.gridSize = 4;
        this.grid = Array(4).fill().map(() => Array(4).fill(null));
        this.score = 0;
        this.bestScore = parseInt(localStorage.getItem('neon_chain_best')) || 0;
        this.tiles = [];
        this.init();
    }

    init() {
        this.bestScoreElement.innerText = this.bestScore;
        document.getElementById('restart-button').addEventListener('click', () => this.restart());
        this.setupControls();
        this.restart();
    }

    restart() {
        this.gameOverElement.style.display = 'none';
        this.tiles.forEach(t => t.element.remove());
        this.tiles = [];
        this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(null));
        this.score = 0;
        this.updateScore(0);
        this.spawnTile();
        this.spawnTile();
    }

    updateScore(points) {
        this.score += points;
        this.scoreElement.innerText = this.score;
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            this.bestScoreElement.innerText = this.bestScore;
            localStorage.setItem('neon_chain_best', this.bestScore);
        }
    }

    spawnTile() {
        const emptyCells = [];
        for (let r = 0; r < this.gridSize; r++) {
            for (let c = 0; c < this.gridSize; c++) {
                if (!this.grid[r][c]) emptyCells.push({ r, c });
            }
        }
        if (emptyCells.length > 0) {
            const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            const level = Math.random() < 0.9 ? 0 : 1;
            const tile = this.createTileElement(r, c, level);
            this.grid[r][c] = tile;
            this.tiles.push(tile);
        }
    }

    createTileElement(r, c, level) {
        const el = document.createElement('div');
        el.className = 'tile tile-new';
        el.innerHTML = `<div class="tile-inner"></div>`;
        this.boardElement.appendChild(el);
        const tile = { element: el, r, c, level };
        this.updateTilePosition(tile);
        return tile;
    }

    updateTilePosition(tile) {
        const spacing = window.innerWidth <= 420 ? 8 : 12;
        const boardWidth = this.boardElement.clientWidth;
        const tileSize = (boardWidth - (spacing * (this.gridSize + 1))) / this.gridSize;
        
        tile.element.style.width = `${tileSize}px`;
        tile.element.style.height = `${tileSize}px`;
        tile.element.style.top = `${spacing + tile.r * (tileSize + spacing)}px`;
        tile.element.style.left = `${spacing + tile.c * (tileSize + spacing)}px`;
        
        const config = ELEMENTS[tile.level] || ELEMENTS[ELEMENTS.length - 1];
        tile.element.style.backgroundColor = config.color;
        tile.element.style.color = config.color; 
        
        const inner = tile.element.querySelector('.tile-inner');
        inner.innerText = config.name;
        inner.style.color = config.textColor;

        // ПРОГРЕССИВНОЕ СВЕЧЕНИЕ (начиная с CELL - индекс 3)
        if (tile.level >= 3) {
            tile.element.classList.add('tile-super');
            
            // Расчет интенсивности (CELL=1, SPARK=2, ..., LASER=5)
            const power = tile.level - 2; 

            // На сколько % свечение выходит за края (от -5% до -45%)
            const glowSize = -(power * 8) + "%"; 
            // Размытие (от 10px до 65px)
            const glowBlur = (power * 12) + "px";
            // Прозрачность (от 0.2 до 0.8)
            const glowOpacity = Math.min(0.1 + (power * 0.15), 0.8);

            tile.element.style.setProperty('--glow-size', glowSize);
            tile.element.style.setProperty('--glow-blur', glowBlur);
            tile.element.style.setProperty('--glow-opacity', glowOpacity);
        } else {
            tile.element.classList.remove('tile-super');
            tile.element.style.boxShadow = '0 4px 8px rgba(0,0,0,0.4)';
        }
    }

    move(direction) {
        if (this.gameOverElement.style.display === 'flex') return;
        let moved = false;
        const mergedThisTurn = new Set();
        const dr = direction === 'up' ? -1 : direction === 'down' ? 1 : 0;
        const dc = direction === 'left' ? -1 : direction === 'right' ? 1 : 0;
        const range = (direction === 'down' || direction === 'right') ? [3, 2, 1, 0] : [0, 1, 2, 3];

        range.forEach(r => {
            range.forEach(c => {
                const tile = this.grid[r][c];
                if (!tile) return;
                let currR = r, currC = c;
                while (true) {
                    const nextR = currR + dr, nextC = currC + dc;
                    if (nextR < 0 || nextR >= 4 || nextC < 0 || nextC >= 4) break;
                    const nextTile = this.grid[nextR][nextC];
                    if (!nextTile) {
                        this.grid[nextR][nextC] = tile;
                        this.grid[currR][currC] = null;
                        currR = nextR; currC = nextC;
                        tile.r = currR; tile.c = currC;
                        moved = true;
                    } else if (nextTile.level === tile.level && !mergedThisTurn.has(nextTile)) {
                        tile.level++;
                        this.updateScore(Math.pow(2, tile.level + 1));
                        
                        tile.element.classList.remove('tile-merged');
                        void tile.element.offsetWidth;
                        tile.element.classList.add('tile-merged');

                        this.grid[nextR][nextC] = tile;
                        this.grid[currR][currC] = null;
                        tile.r = nextR; tile.c = nextC;
                        nextTile.element.remove();
                        this.tiles = this.tiles.filter(t => t !== nextTile);
                        mergedThisTurn.add(tile);
                        moved = true;
                        break;
                    } else break;
                }
                if (moved) this.updateTilePosition(tile);
            });
        });

        if (moved) {
            setTimeout(() => {
                this.spawnTile();
                if (this.checkGameOver()) this.gameOverElement.style.display = 'flex';
            }, 180);
        }
    }

    checkGameOver() {
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (!this.grid[r][c]) return false;
                if (r < 3 && this.grid[r][c].level === this.grid[r+1][c].level) return false;
                if (c < 3 && this.grid[r][c].level === this.grid[r][c+1].level) return false;
            }
        }
        return true;
    }

    setupControls() {
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (['w', 'arrowup'].includes(key)) this.move('up');
            if (['s', 'arrowdown'].includes(key)) this.move('down');
            if (['a', 'arrowleft'].includes(key)) this.move('left');
            if (['d', 'arrowright'].includes(key)) this.move('right');
        });
        let tsX, tsY;
        document.addEventListener('touchstart', (e) => {
            tsX = e.touches[0].clientX; tsY = e.touches[0].clientY;
        }, { passive: true });
        document.addEventListener('touchend', (e) => {
            const dx = e.changedTouches[0].clientX - tsX;
            const dy = e.changedTouches[0].clientY - tsY;
            if (Math.max(Math.abs(dx), Math.abs(dy)) > 30) {
                if (Math.abs(dx) > Math.abs(dy)) this.move(dx > 0 ? 'right' : 'left');
                else this.move(dy > 0 ? 'down' : 'up');
            }
        }, { passive: true });
    }
}

window.game = new Game2048();